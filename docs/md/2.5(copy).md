# 事件通信

::: tip 阅读本文大概需要 10 分钟。

事件通信是做什么用的，如字面意思，是用来通信的。

那么是用来谁和谁通信的？

对联机游戏的概念有所了解之后，我们知道代码会在两个端执行，一个是客户端，一个是在服务端。所以通信方式可以归类为以下几种：

* 客户端 -> 客户端
* 服务端 -> 服务端
* 客户端 -> 服务端
* 服务端 -> 客户端

本章节将详细介绍上面这几种场景的通信。

:::

本文会讲解部分网络通信的信息，更多网络相关查看产品文档：[网络同步原理和结构](https://docs.ark.online/Scripting/NetworkSynchronizationStructureandMechanics.html)

TODO：

1. 包含 Events
2. 包含 Core.Function
3. 包含 Replicated
4. 包含关键词：脚本与脚本之间的通信

## 1. 本地事件

客户端发送事件到客户端，服务端发送事件到服务端，都属于本地事件。

在游戏逻辑中，脚本之间的通信方式其实有很多种，事件就是其中一种使用比较便捷的方式。

下面我们演示一下，同在客户端或者同为服务端的脚本情况下，如何让 A 脚本，调用 B 脚本的某个函数，使用事件通信的方式来实现。

### 发送本地事件-客户端

* 新创建一个脚本，命名为 'GameStart' 

![image-20230529111824370](https://arkimg.ark.online/image-20230529111824370.webp)

* 双击打开脚本，在 onStart 函数中，判断客户端环境后，添加一个延时代码，5 秒后发送一个事件：

```typescript
@Core.Class
export default class GameStart extends Core.Script {

    /** 当脚本被实例后，会在第一帧更新前调用此函数 */
    protected onStart(): void {
        if(SystemUtil.isClient()){	//[!code focus]
            // 判断环境是客户端，延时 5 秒后发送一个事件	//[!code focus]
            setTimeout(() => {	//[!code focus]
                // 发送本地事件，事件名我们可以随便自定义，但是要保证发送方和接收方的事件名一致，否则接收不到事件	//[!code focus]
                // 这里我们定义事件名为"client_local_event_test"	//[!code focus]
                Events.dispatchLocal("client_local_event_test")	//[!code focus]
            }, 5000);	//[!code focus]
        }	//[!code focus]
    }

    /**
     * 周期函数 每帧执行
     * 此函数执行需要将 this.useUpdate 赋值为 true
     * @param dt 当前帧与上一帧的延迟 / 秒
     */
    protected onUpdate(dt: number): void {

    }

    /** 脚本被销毁时最后一帧执行完调用此函数 */
    protected onDestroy(): void {

    }
}
```

* 代码改完，我们把 `GameStart` 脚本挂载到场景下，依然和之前操作一样，拖拽到对象管理器的"对象"下面即可

![image-20230529131702333](https://arkimg.ark.online/image-20230529131702333.webp)

* 现在我们在 `GameStart` 脚本中，发送了一个名为 `client_local_event_test` 的事件，下面我们在另外一个脚本中接收事件，并调用其他函数处理业务逻辑

### 接收本地事件-客户端

* 这里我们就不新建一个脚本了，打开之前我们操作的 `PlayerControl` 脚本（如果之前没有创建，就创建一个），在 `onStart` 函数中添加判断客户端的代码，编写监听 `client_local_event_test` 事件的代码，在接收事件后打印日志，示例如下：

```typescript
@Core.Class
export default class PlayerControl extends Core.Script {

    /** 当脚本被实例后，会在第一帧更新前调用此函数 */
    protected onStart(): void {
        if (SystemUtil.isClient()) {	//[!code focus]
            // 在客户端，监听 client_local_event_test 事件	//[!code focus]
            Events.addLocalListener("client_local_event_test", () => {	//[!code focus]
                console.log("收到了来自 GameStart 的客户端本地事件");	//[!code focus]
            });	//[!code focus]
        }	//[!code focus]
    }

    /**
     * 周期函数 每帧执行
     * 此函数执行需要将 this.useUpdate 赋值为 true
     * @param dt 当前帧与上一帧的延迟 / 秒
     */
    protected onUpdate(dt: number): void {

    }

    /** 脚本被销毁时最后一帧执行完调用此函数 */
    protected onDestroy(): void {

    }
}
```

> 代码中，`() =>{} `的形式是 ts 语法中的匿名函数，在大括号中写其他想要执行的代码即可。这个是无参数的情况。
>
> 有参数时，假设有一个 string 类型的参数，就会变成这样 `(param: string) => {}`，下面的小节里面还会单独介绍带参数的事件发送和接收。
>

* 改完代码后保存，回到编辑器。点击“运行”按钮
* 运行起来，等待 5 秒后，可以看到编辑器的客户端日志窗口中，已经打印了我们刚才编写的语句，如图：

![image-20230529132126018](https://arkimg.ark.online/image-20230529132126018.webp)

我们演示了 A 脚本，如何使用事件通信让 B 脚本执行一段代码，可以看到其实核心就两个部分：

1. 发送事件：`Events.dispatchLocal(eventName)`
2. 接收事件：`Events.addLocalListener(eventName, callback);`

上面例子里面都是客户端，那么如果是同为服务端呢，也就是服务端发消息给服务端该如何通信，其实是完全一样的做法，通过函数名能判断得出来，其实就是本地接收事件和本地发送事件的方法。所以在服务端也是完全适用的，这里就不再赘述。

### 带参数的演示

上面都是无参的情况，这里演示一下携带一个 string 类型的参数，如何发送和接收事件：

* 修改发送事件的脚本，打开 `GameStart` 脚本，更改发送事件那行代码，在最后加上一个参数：

* > 这里为了演示方便，把暂时没有用的 onUpdate、onDestroy 两个函数删除了

```typescript
  @Core.Class
  export default class GameStart extends Core.Script {
  
      /** 当脚本被实例后，会在第一帧更新前调用此函数 */
      protected onStart(): void {
          if(SystemUtil.isClient()){
              // 判断环境是客户端，延时 5 秒后发送一个事件
              setTimeout(() => {
                  // 发送本地事件，事件名我们可以随便自定义，但是要保证发送方和接收方的事件名一致，否则接收不到事件
                  // 这里我们定义事件名为"client_local_event_test"
                  Events.dispatchLocal("client_local_event_test", "参数 01")	//[!code focus]
              }, 5000);
          }
      }
  }
```

* 修改接收事件的脚本 `PlayerControl` ，多接收一个参数，并打印出来，代码如下：

```typescript
  @Core.Class
  export default class PlayerControl extends Core.Script {
  
      /** 当脚本被实例后，会在第一帧更新前调用此函数 */
      protected onStart(): void {
          if (SystemUtil.isClient()) {
              // 在客户端，监听 client_local_event_test 事件
              Events.addLocalListener("client_local_event_test", (param: string) => {	//[!code focus]
                  console.log("收到了来自 GameStart 的客户端本地事件", param);	//[!code focus]
              });
          }
      }
  }
```

* 点击运行，过 5 秒之后可以看到客户端日志窗口的打印日志，如下：

![image-20230529135600380](https://arkimg.ark.online/image-20230529135600380.webp)



## 2. 客户端发消息给服务端

* Events.dispatchToServer()





## 3. 服务端发消息给客户端

* Events.dispatchToClient()
* Events.dispatchToAllClient()



## 4. 扩展-Core.Function



## 5. 扩展-属性同步(Replicated)