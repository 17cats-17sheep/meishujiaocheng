# 场景内物体/脚本的单双端设计

## 单双端介绍

单双端的详细文档可以阅读：[网络同步原理和结构 | 产品手册 (ark.online)](https://docs.ark.online/Scripting/NetworkSynchronizationStructureandMechanics.html)

单双端包含三种情况，完整描述应该如下所示：

- **网络状态为客户端（单端）**：物体只在客户端创建 / 脚本只在客户端运行
- **网络状态为服务端（单端）**：物体只在服务端保留节点信息 / 脚本只在服务端运行
- **网络状态为双端**： 物体在服务端保留节点信息，在客户端创建物体 / 脚本在双端运行

## 修改物体 / 脚本的单双端

![image-20230519164353771](https://arkimg.ark.online/image-20230519164353771.png)

<center>（图 1 修改网络状态）</center>

如图所示，在对象管理窗口中，每个物体的右侧都有一个按钮，单击按钮即可进行网络状态的切换。

- **S&C** 代表双端

- **S** 代表服务端

- **C** 代表客户端

## 不同网络状态下物体的特点

### 1.网络状态为客户端（客户端物体）

- 碰撞：当物体网络状态被切换到客户端时，物体的碰撞会被自动关闭
- 显示：客户端可以看到客户端物体
- 操作：服务端不能直接对客户端物体进行操作

### 2.网络状态为服务端（服务端物体）

服务端物体一般来说是没有任何意义的，因为我们创建的物体大多都需要进行渲染、或是播放声音、或是产生碰撞。所以对于服务端物体，客户端是查不觉不到它的存在的。

::: tip 服务端脚本的意义

虽然**服务端物体**的作用比较小，但是**服务端脚本**却是经常使用的，我们可以修改脚本的网络状态为服务端，让它只在服务端运行逻辑。

:::

### 3.网络状态为双端（双端物体）

- 碰撞：双端物体会默认将碰撞打开
- 显示：客户端可以看到双端物体
- 操作：服务端可以直接对双端物体进行操作，并且物体的变化会同步给每个客户端

## 用代码控制脚本的运行环境

我们可以使用 API： **SystemUtil.isClient()** 和 **SystemUtil.isServer()** 来对运行环境进行区分，从而实现用代码控制脚本的运行环境。

具体应用如下：

```typescript
@Core.Class
export default class Test extends Core.Script {

    /** 当脚本被实例后，会在第一帧更新前调用此函数 */
    protected onStart(): void {

        if (SystemUtil.isClient()) {
            // 这部分逻辑只在客户端执行
        }

        if (SystemUtil.isServer()) {
            // 这部分逻辑只在服务端执行
        }

        // 这部分逻辑在双端都执行
    }
}
```

## 单双端对服务端性能的影响

关于性能这个话题，咱们目前阶段只需要考虑 **服务端内存消耗** 和 **服务端 CPU 消耗** ，因为客户端的性能根据不同的设备也有不同的标准，你做的游戏可能会出现部分人游玩流畅，部分人游玩卡顿的情况。但是服务端的性能是相对固定的，如果服务端的性能没有处理好，就会导致所有设备的玩家都会出现卡顿，所以关注服务端性能是一件重要的事情。

- **客户端物体**：

  由于服务端完全不需要保存客户端物体的节点信息，也不需要同步客户端物体的状态，所以客户端物体对于服务端内存以及服务端 CPU 的消耗都是最低的

- **服务端物体**：

  服务端会维护服务端物体的节点信息，相对于客户端来说会多一份内存消耗，但是服务端物体不需要向客户端进行同步，所以 CPU 的消耗也比较低。

  ::: tip 服务端脚本

  虽然服务端脚本占用的内存较小，但是脚本中如果写了复杂的逻辑，就会导致服务端的计算量上升，使得 CPU 消耗增大。因此我们在编写服务端脚本时，要注意优化自己的代码逻辑，避免不必要的消耗。

  :::

- **双端物体：**

  服务端不仅会维护双端物体的节点信息，也会在客户端链接上服务端时，向客户端同步数据，所以服务端内存和服务端 CPU 消耗都是最高的。

  ::: tip 双端**动态**物体和双端**静态**物体

  双端动态物体代表着服务端必须随时同步状态给客户端，而双端静态物体只需要在客户端连接上服务端时同步一次即可。所以双端静态物体相对于双端动态物体来说，是能够节省很大一部分性能的。因此我们在实际开发过程中要尽量避免创建较多的双端动态物体。

  :::